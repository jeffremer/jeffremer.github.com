---
layout: posts
title: Fliteapp, REST, DSL, Tools
categories: 
- flite
date: 2011-04-15-14:00
---

REST API
===============================================================================

This is the specification for the minimal necessary Flite REST API for the core Widgetbox object model.  Authentication would be per user.

Registration
-------------------------------------------------------------------------------

### List

	GET /registrations

### Read

	GET /registration/[guid]

### Create

	POST /registration

Parameters:

	* html: HTML Content
	* custom_config: Custom Config Content
	* script: Script Content
	* css: CSS Content
	* config_params: Configuration Parameter Map
	
All optional.	

### Update

	PUT /registration/[guid]

Parameters:

	* html: HTML Content
	* custom_config: Custom Config Content
	* script: Script Content
	* css: CSS Content
	* config_params: Configuration Parameter Map
	
All optional.

### Delete

	DELETE /registration/[guid]

Instance
-------------------------------------------------------------------------------

### List

	GET /instances

### Read

	GET /instance/[guid]

### Create

	POST /instance

Parameters:

	* guid: Registration GUID (required)
	* Configuration Parameter Value Map (optional)

### Update

	PUT /instance/[guid]

Parameters:

	* Configuration Parameter Map (optional)

### Delete

	DELETE /registration/[guid]
	
Domain Specific Language
===============================================================================

The core Widgetbox object model no longer reflects the products that we sell.
Instead we've started talking about Components, Canvases, Streams, etc...not
the Registrations or Instances that tie everything together.  I believe we
should be working with tools that reflect the products we are creating, but
those tools should be flexible enough that they need not affect the proven
Widgetbox object model we've relied on for years.

That's where a Flite Domain Specific language comes into play.  The Flite DSL
takes over where the REST API leaves off and provides a flexible framework for
defining our products and makes up a tool set that makes it easy to create the
products and instances of the products.

This is all up for grabs based on whatever someone thinks best comprises the
Flite domain model.  However every domain model definition would generally be
defined in much the same way, primarily as a friendly wrapper around the REST API
aimed at providing a definition for creating domain model object.

Something like this.  

	Flite::Object do
		blueprint do
			# Define the Object's composition
		    # and required and optional attributes			
		end
	 
		list do
			# REST API calls
			# Business logic...
			# Differentiate between locally created objects
			# and those synced to the server if doing this out of band
		end
		
		create do
			#...
		end
		
		read do
			#...
		end
		
		update do
			#...
		end
		
		delete do
			#...
		end
	end		


Domain Models
-------------------------------------------------------------------------------

These are the components that I understand compose a Flite product package.
Some like the Stream and Canvas may be optional.

* Component
* Stream
* Canvas
* Placement
* Campaign 

Every domain model definition would follow at least the above template and would
define the model's composition in terms of the local toolchain's available data
and the internal plumbing required via the REST API to sync those objects to the
server.

For example.

	Flite::Component do
		blueprint do |model|
			model.prototype :registration
			model.instance :instance
			model.has_many :instances
			
			require name
			optional html
			# ... and so on.
		end
 
		# This implementation is probably common to all objects
		# but could be extend to show children, extensions, etc...
		list do
			rest.get(model.prototype.pluralize) do |results|
				results.each do |result|
					puts result
				end
			end					
		end
	    
		content_types = {
			:html => 'html',
			:config => 'html',
			:script => 'js',
			:css => 'css'
		}
	
		create do |name, html,...|
			# Make a component folder
			Dir.mkdir("components/#{name}")
			  unless Dir.exists?("components/#{name}")
			[:html, :config, :script, :css] do |content|
				FileUtils.touch
				  "components/#{name}/#{name}_#{content}.#{content_types[content]}"
			end
		
			# Get and serialize data
			data = # Gather data from above files
			rest.post(rest.model.prototype, data) do |response|
				# Do something with the response
				# Maybe create an instance by default?
			end
			
			# Do more stuff like commit to a repository, etc..
		end
		
		# ... and so on.
		
		# Different components have different instantiation methods
		# specific to their corresponding Widgetbox object model
		
		instantiate do |name|
		   # Do something clever like create a git branch 
		   # in the component's directly that contains only the
		   # settings.json which represents an Instance of a Registration
		   rest.post(rest.model.instance, 'settings.json')
		end
	   
	end

Tools
===============================================================================

The Flite tool chain is the manifestation of the DSL.  It contains the tools
necessary for activating and managing the domain model objects. The template
for defining domain models translates into an executable toolchain by simply
calling a method on an object.

Imagine the following commands that creates a Flite component, then an instance
of that component and update it on the server.

	$[~] fliteapp init MyFliteAd
	Creating MyFliteAd
		mkdir MyFliteAd: new
		mkdir MyFliteAd:components: new
		... # And so on
	$[~] cd MyFliteAd
	$[~/MyFliteAd] fliteapp create component Form
	Creating Form component:
		mkdir components: exists
		mkdir components/Form: new
		create components/Form/Form_html.html: new
		create components/Form/Form_config.html: new
		create components/Form/Form_script.js: new
		create components/Form/Form_css.css: new
		create components/Form/Form_setting.json: new								
	$[~/MyFliteAd] # Do some editing of the component data
	$[~/MyFliteAd] ...
	$[~/MyFliteAd] fliteapp component update Form
	Pushing Form component:
	...
	$[~/MyFliteAd] fliteapp component instantiate Form myform
	Instantating Form component:
		cd components/Form
		# Edit index so that it only contains settings.json
		git symbolic-ref HEAD refs/heads/myform
		rm .git/index
		git clean -fdx
		git checkout master settings.json		
	$[~/MyFliteAd] cd components/form
	$[~/MyFliteAd] git branch
	master
	* myform	
	$[~/MyFliteAd] # Edit the settings.json
	$[~/MyFliteAd] flite app update component Form myform
	
	... and so on

Here's a command sequence that could assemble a set of component instances
into a Canvas

	$[~/MyFliteAd] fliteapp canvas create MyCanvas
	Creating MyCanvas canvas
		mkdir canvases: exists
		mkdir canvases/MyCanvas: new
		create canvases/MyCanvase/settings.json: new 
	$[~/MyFliteAd] fliteapp canvas add myform, myslideshow, mywidget
	Adding myform, myslideshow, mywidget to MyCanvas
		Updating setting.json: updated
		
	$[~/MyFliteAd] fliteapp canvas udpate MyCanvas
	Pushing MyCanvas...done.